/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ORC_FILE_HH
#define ORC_FILE_HH

#include <string>

namespace orc {

  extern const std::string MAGIC;

  /**
   * Create a version number for the ORC file format, so that we can add
   * non-forward compatible changes in the future. To make it easier for users
   * to understand the version numbers, we use the Hive release number that
   * first wrote that version of ORC files.
   *
   * Thus, if you add new encodings or other non-forward compatible changes
   * to ORC files, which prevent the old reader from reading the new format,
   * you should change these variable to reflect the next Hive release number.
   * Non-forward compatible changes should never be added in patch releases.
   *
   * Do not make any changes that break backwards compatibility, which would
   * prevent the new reader from reading ORC files generated by any released
   * version of Hive.
   */
  enum Version {
    V_0_11 = 0,
    V_0_12 = 1
  };

  Version getVersionByName(const std::string&);
  const std::string& getVersionName(Version version);
  int getMajorVersion(Version version);
  int getMinorVersion(Version version);

  static const Version CURRENT_VERSION = V_0_12;

  enum EncodingStrategy {
    SPEED = 0, 
    COMPRESSION = 1;
  };

  enum CompressionStrategy {
    SPEED = 0, 
    COMPRESSION = 1;
  };

  /**
   * Enum container for all orc table properties.
   * If introducing a new orc-specific table property,
   * add it here.
   */
  enum OrcTableProperties {
    COMPRESSION = 0,
    COMPRESSION_BLOCK_SIZE = 1,
    STRIPE_SIZE = 2,
    BLOCK_SIZE = 3,
    ROW_INDEX_STRIDE = 4,
    ENABLE_INDEXES = 5,
    BLOCK_PADDING = 6,
    ENCODING_STRATEGY = 7
  };
  const std::string& getTablePropertyName(OrcTableProperty property);

  class ReaderOptions {
  public:
    ReaderOptions();
    ReaderOptions path(const std::string& path);
    ReaderOptions maxLength(long maxLength);
  private:
    std::string path;
    long maxLength;
  };

  Reader* createReader(const ReaderOptions& options);

  class WriterContext {
  public:
    virtual ~WriterContext();
    virtual Writer& getWriter() const = 0;
  };

  class WriterCallback {
  public:
    virtual ~WriterCallback();
    virtual void preStripeWrite(const WriterContext& context) const = 0;
    virtual void preFooterWrite(const WriterContext& context) const = 0;
  }

  /**
   * Options for creating ORC file writers.
   */
  class WriterOptions {
  public:
    WriterOptions();

    /**
     * Set the stripe size for the file. The writer stores the contents of the
     * stripe in memory until this memory limit is reached and the stripe
     * is flushed to the HDFS file and the next stripe started.
     */
    WriterOptions stripeSize(long value);

    /**
     * Set the file system block size for the file. For optimal performance,
     * set the block size to be multiple factors of stripe size.
     */
    WriterOptions blockSize(long value);

    /**
     * Set the distance between entries in the row index. The minimum value is
     * 1000 to prevent the index from overwhelming the data. If the stride is
     * set to 0, no indexes will be included in the file.
     */
    WriterOptions rowIndexStride(int value);

    /**
     * The size of the memory buffers used for compressing and storing the
     * stripe in memory.
     */
    WriterOptions bufferSize(int value);

    /**
     * Sets whether the HDFS blocks are padded to prevent stripes from
     * straddling blocks. Padding improves locality and thus the speed of
     * reading, but costs space.
     */
    WriterOptions blockPadding(boolean value);

    /**
     * Sets the encoding strategy that is used to encode the data.
     */
    WriterOptions encodingStrategy(EncodingStrategy strategy);

    /**
     * Sets the tolerance for block padding as a percentage of stripe size.
     */
    WriterOptions paddingTolerance(float value);

    /**
     * Sets the generic compression that is used to compress the data.
     */
    WriterOptions compress(CompressionKind value);

    /**
     * A required option that sets the type for the rows.
     */
    WriterOptions rowType(const TypeDescription* value);

    /**
     * Sets the version of the file that will be written.
     */
    WriterOptions version(Version value);

    /**
     * Add a listener for when the stripe and file are about to be closed.
     * @param callback the object to be called when the stripe is closed
     * @return
     */
    WriterOptions callback(WriterCallback* callback);

    /**
     * A package local option to set the memory manager.
     */
    WriterOptions memoryManager(MemoryManager* value);

  private:
    const TypeDescription* typeDescription;
    long stripeSizeValue;
    long blockSizeValue;
    int rowIndexStrideValue;
    int bufferSizeValue;
    boolean blockPaddingValue;
    CompressionKind compressValue;
    MemoryManager* memoryManagerValue;
    Version versionValue;
    WriterCallback* callback;
    EncodingStrategy encodingStrategy;
    CompressionStrategy compressionStrategy;
    float paddingTolerance;
  }

  /**
   * Create an ORC file writer. This is the public interface for creating
   * writers going forward and new options will only be added to this method.
   * @param path filename to write to
   * @param opts the options
   * @return a new ORC file writer
   * @throws IOException
   */
  public static Writer createWriter(const WriterOptions& opts);

#endif
